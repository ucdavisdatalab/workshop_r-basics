{
  "hash": "d480e7bb7bee1f83d7da5df0e32f5c98",
  "result": {
    "engine": "knitr",
    "markdown": "# Appendix\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n\n## More About Comparisons {#sec-more-about-comparisons}\n\n### Equality\n\nThe `==` operator is the primary way to test whether two values are equal, as\nexplained in @sec-comparisons. Nonetheless, equality can be defined in many\ndifferent ways, especially when dealing with computers. As a result, R also\nprovides several different functions to test for different kinds of equality.\nThis describes tests of equality in more detail, and also describes some other\nimportant details of comparisons.\n\n\n#### The `==` Operator\n\nThe `==` operator tests whether its two arguments have the exact same\nrepresentation as a [**binary number**][binary] in your computer's memory.\nBefore testing the arguments, the operator applies R's rules for vectorization\n(@sec-vectorization), recycling (@sec-recycling), and implicit coercion\n(@sec-implicit-coercion). Until you've fully internalized these three rules,\nsome results from the equality operator  may seem surprising. For example:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Recycling:\nc(1, 2) == c(1, 2, 1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE TRUE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Implicit coercion:\nTRUE == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE == \"TRUE\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 == \"TRUE\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe length of the result from the equality operator is usually the same as its\nlongest argument (with some exceptions).\n\n[binary]: https://en.wikipedia.org/wiki/Binary_number\n\n\n#### The `all.equal` Function\n\nThe `all.equal` function tests whether its two arguments are equal up to some\nacceptable difference called a **tolerance**. Computer representations for\ndecimal numbers are inherently imprecise, so it's necessary to allow for very\nsmall differences between computed numbers. For example:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 0.5 - 0.3\ny = 0.3 - 0.1\n\n# FALSE on most machines:\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# TRUE:\nall.equal(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe `all.equal` function does not apply R's rules for vectorization, recycling,\nor implicit coercion. The function returns `TRUE` when the arguments are equal,\nand returns a string summarizing the differences when they are not. For\ninstance:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(1, c(1, 2, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Numeric: lengths (1, 3) differ\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe `all.equal` function is often used together with the `isTRUE` function,\nwhich tests whether the result is `TRUE`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mean relative difference: 0.3333333\"\n```\n\n\n:::\n\n```{.r .cell-code}\nisTRUE(all.equal(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nYou should generally use the `all.equal` function when you want to compare\ndecimal numbers.\n\n\n#### The `identical` Function\n\nThe `identical` function checks whether its arguments are completely identical,\nincluding their metadata (names, dimensions, and so on). For instance:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list(a = 1)\ny = list(a = 1)\nz = list(1)\n\nidentical(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(x, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe `identical` function does not apply R's rules for vectorization, recycling,\nor implicit coercion. The result is always a single logical value.\n\nYou'll generally use the `identical` function to compare non-vector objects\nsuch as lists or data frames. The function also works for vectors, but most of\nthe time the equality operator `==` is sufficient.\n\n\n### The `%in%` Operator\n\nAnother common comparison is to check whether elements of one vector are\ncontained in another vector at any position. For instance, suppose you want to\ncheck whether `1` or `2` appear anywhere in a longer vector `x`. Here's how to\ndo it:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(3, 4, 2, 7, 3, 7)\nc(1, 2) %in% x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nR returns `FALSE` for the `1` because there's no `1` in `x`, and returns `TRUE`\nfor the `2` because there is a `2` in `x`.\n\nNotice that this is different from comparing with the equality operator `==`.\nIf you use use the equality operator, the shorter vector is recycled until its\nlength matches the longer one, and then compared element-by-element. For the\nexample, this means only the elements at odd-numbered positions are compared to\n`1`, and only the elements at even-numbered positions are compared to `2`:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2) == x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n### Summarizing Comparisons\n\nThe comparison operators are vectorized, so they compare their arguments\nelement-by-element:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) < c(1, 3, -3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"he\", \"saw\", \"her\") == c(\"she\", \"saw\", \"him\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWhat if you want to summarize whether all the elements in a vector are equal\n(or unequal)? You can use the `all` function on any logical vector to get a\nsummary. The `all` function takes a vector of logical values and returns `TRUE`\nif all of them are `TRUE`, and returns `FALSE` otherwise:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(c(1, 2, 3) < c(1, 3, -3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe related `any` function returns `TRUE` if any one element is `TRUE`, and\nreturns `FALSE` otherwise:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(c(\"hi\", \"hello\") == c(\"hi\", \"bye\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n### Other Pitfalls\n\nNew programmers sometimes incorrectly think they need to append `== TRUE` to\ntheir comparisons. This is redundant, makes your code harder to understand, and\nwastes computational time. Comparisons already return logical values. If the\nresult of the comparison is `TRUE`, then `TRUE == TRUE` is again just `TRUE`.\nIf the result is `FALSE`, then `FALSE == TRUE` is again just `FALSE`. Likewise,\nif you want to invert a condition, choose an appropriate operator rather than\nappending `== FALSE`.\n\n\n## The `drop` Parameter {#sec-the-drop-parameter}\n\nIf you use two-dimensional indexing with `[` to select exactly one column, you\nget a vector:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = banknotes[1:3, 2]\nclass(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe container is dropped, even though the indexing operator `[` usually keeps\ncontainers. This also occurs for matrices. You can control this behavior with\nthe `drop` parameter:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult = banknotes[1:3, 2, drop = FALSE]\nclass(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe default is `drop = TRUE`.\n",
    "supporting": [
      "05_appendix_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}